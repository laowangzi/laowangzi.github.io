---
published: true
title: 数据结构取最大
category: algorithm
tags: 
  - algorithm
  - leetcode
layout: post

---

本篇源于offer-30（包含min函数的栈）、offer-59(滑动窗口最大值)和offer-59-2(队列最大值)。可以简单地总结为“数据结构取最大值”问题。因为解决的思路相似，在此进行总结。

## 一、问题描述

所谓”数据结构取最大值“问题，不论是栈、队列还是滑动窗口，都是要求实现一个函数，可以在<strong>O(1)</strong>的时间复杂度下得到数据结构中当前的最大（最小）值。如滑动窗口最大值的题目描述如下：

	请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

	若队列为空，pop_front 和 max_value 需要返回 -1
	
	输入: 
	["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
	[[],[1],[2],[],[],[]]
	输出: [null,null,null,2,1,2]

## 二、解决思路

要求**O(1)**的时间复杂度，天下没有免费的午餐，只能利用额外空间来换取时间。有了这个思想之后，下一步就是确定额外空间所需要使用的数据结构，目标是：维护该数据结构，配合某种对数据的操作规则，可以在O(1)得到当前原数据结构的最小值。下面依次分析这三个问题的解决方法：

### 2.1 offer-30 包含min函数的栈

本题的解决思路是选取一个栈作为额外的数据结构空间。设原栈为A，额外空间栈为B，目标是设计规则，**让B的栈顶始终是当前A栈中的最小值元素**。规则如下：

	入栈：每当A入栈一个新数据，若该数据小于等于B栈顶，则该数据入栈栈B。

	出栈：每当A出栈一个新数据，若该数据等于B栈顶，则B的栈顶也跟着出栈。

	min函数时间复杂度O(1)，空间复杂度O(N)

#### 2.1.1 为什么可行及为什么选择栈这种数据结构的思考

使用栈这种数据结构主要是因为原栈A先入后出的特性所决定的。先进入的元素若已经最小，则后来的元素对于min函数来说已经是没有价值的信息可以丢弃，直到该最小元素被出栈，min的情况才会变化。

### 2.2 offer-59 滑动窗口最大值

本题要求滑动窗口从左向右移动，**O(1)**求出每个窗口的最大值。维护的数据结构是队列，只不过是双端队列（队列两边均可进出）。设计的规则目标是**让队头保持当前窗口最大值**。规则如下：

	窗口每滑动一次，若减少的值等于队头，则将队头按常规规则出队。
	对于新来的值，将队列中所有小于新值的数字从非常规规则端出队，然后将该新值入队。

#### 2.2.1 为什么可行及为什么选择双端队列

与栈的最大值思路一样，总结起来用了两点：

	1、耗费额外空间提升时间性能。
	2、利用数据结构的特点满足要求。

第二点解释为：在对额外空间进行利用的时候，由原有数据结构的特点对额外空间进行合理操作。比如：对于栈最大值的问题来说，如果栈底层的值很大，那么在B栈中后来进入A栈的元素可以直接舍弃，因为出栈直到该最大值时整体的最大值才会发生变化。

### 2.3 offer-59-2 队列最大值

这个问题与上一个问题相比，最大的区别是对于滑动窗口来说，每次进一个新值出一个旧值这个是固定的，而队列则可以进行连续的入队出队操作。但这反映到额外空间的数据结构上似乎并没有对规则造成什么影响。

因此，该解法与上题类似，不再赘述。

